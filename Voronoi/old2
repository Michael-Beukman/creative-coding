const cDiv = document.getElementById("canvasDiv");
class Line{
  constructor(x, y, ex,  ey){
    this.x = x;
    this.y = y;
    this.ex = ex;
    this.ey = ey;
    this.dx = ex - x;
    this.dy = ey - y;
    this.m = this.dy/this.dx;
    this.c = this.y - this.m * this.x;

    this.minX = min(x, ex);
    this.maxX = max(x, ex);

    this.minY = min(y, ey);
    this.maxY = max(y, ey);
  }

  inX(x){
    return x >= this.minX && x <= this.maxX;
  }
  inY(y){
    return y >= this.minY && y <= this.maxY;
  }

  isInBetween(point){
    if (this.inX(point.x) && this.inY(point.y)){
        if (this.dx == 0){
          return point.x == this.x;
        }else{
          return this.m * point.x + this.c == point.y;
        }
    }

    return false;
  }

  getIntersectPoint(other){
    if (this.dx == 0 && other.dx == 0){
      if (this.x == other.x) return createVector(this.x, this.y);
      return null;
    }
    if (this.dx == 0){
      const otherY = other.m * this.x + other.c;
      if (this.inY(otherY)){
        return createVector(this.x, otherY);
      }
    }else if (other.dx == 0){
      return other.getIntersectPoint(this);
    }else{
      // todo same slope
      if (this.m == other.m){
        if (this.c == other.c) {
          return createVector(this.x, this.y);
        }
        return null;
      }
      const x = (other.c - this.c)/(this.m - other.m);
      const y = this.m * x + this.c;
      return createVector(x, y);
    }
    return null;
  }

  length(){
    return sqrt(pow(this.x - this.ex, 2) + pow(this.y - this.ey, 2));
  }

  unitVec(){
    const n = this.length();
    return new Line(0, 0, (this.ex - this.x)/n, (this.ey - this.y)/n);
    
  }

  angle(other){
    const l1 = this.unitVec();
    const l2 = other.unitVec();
    const dot = l1.ex * l2.ex + l1.ey * l2.ey;
    return acos(dot);
  }
}
let cols = [];
let boundaries = [];
let points = [];
let radii = []
let lines = [];
let speeds = [1, 0, 1];
let polygonLines = [];

function calculateLineCircleIntersection(line, center, radius){
  // 
  fill(0,255,0);
  if (line.dx == 0){
    const x = line.x;
    const a = center.x, b = center.y;
    const X = line.x - a;
    const disc = radius*radius - X * X;
    if (disc <0 ) return null;
    const s = sqrt(disc);
    const y1 = b + s;
    const y2 = b - s;
    // ellipse(x, y1, 10); ellipse(x, y2, 10);
    return [createVector(x, y1), createVector(x, y2)];
  }else{
    const a = center.x, b = center.y;
    const m = line.m;
    const c = line.c;
    const A = c - b;
    
    const alpha = m * m + 1;
    const beta = 2 * (m * A - a);
    const gamma = A * A + a * a - radius * radius;

    const disc = (beta*beta - 4 * alpha * gamma);
    if (disc < 0) return null; // no intersection
    const s = sqrt(disc);
    const x1 = (-beta + s)/(2 * alpha);
    const x2 = (-beta - s)/(2 * alpha);

    const y1 = m * x1 + c;
    const y2 = m * x2 + c;

    // ellipse(x1, y1, 10); ellipse(x2, y2, 10);
    return [createVector(x1, y1), createVector(x2, y2)];
  }

}

function calculateAreaOfCircleInsidePolygon(center, radius){
  // calculates the area enclosed by the circle inside the polygon
  let intersectLines = [];
  let whoIsNotIn = [];
  for (let line of polygonLines){
      const intersect = calculateLineCircleIntersection(line, center, radius);
      if (intersect === null) continue; // no intersect
      const p1 = intersect[0], p2 = intersect[1];
      const obj = [];
      if (line.isInBetween(p1)){
        ellipse(p1.x, p1.y, 10);
      }else{
        obj.push(p1);
      }
      if (line.isInBetween(p2)){
        ellipse(p2.x, p2.y, 10);
      }else{
        obj.push(p2);
      }
      
      intersectLines.push(new Line(p1.x, p1.y, p2.x, p2.y));
      whoIsNotIn.push(obj);
      // need to find the area of the 
      // need to check if these are between start & end of line;
  }

  let doubleLines = [];
  let totalArea = 0;
  for (let i=0; i < intersectLines.length; ++i){
    const l = intersectLines[i];
      for (let j=i+1; j< intersectLines.length; ++j){
          const intersectPoint = intersectLines[i].getIntersectPoint(intersectLines[j]);
          if (intersectPoint === null) continue;
          ellipse(intersectPoint.x ,intersectPoint.y, 10);
          stroke(0,0,255);

          line(center.x ,center.y, whoIsNotIn[i][0].x, whoIsNotIn[i][0].y);
          line(center.x ,center.y, whoIsNotIn[j][0].x, whoIsNotIn[j][0].y);
          line(center.x ,center.y, intersectPoint.x, intersectPoint.y);
          // now subtract area of intersection sector

          const l1 = new Line(center.x, center.y, whoIsNotIn[i][0].x, whoIsNotIn[i][0].y);
          const l2 = new Line(center.x ,center.y, whoIsNotIn[j][0].x, whoIsNotIn[j][0].y);
          const alpha = l1.angle(l2);
          const midLine = new Line(center.x ,center.y, intersectPoint.x, intersectPoint.y);
          // const leftLine = new Line(intersectPoint.x, intersectPoint.y, whoIsNotIn[i][0].x, whoIsNotIn[i][0].y);
          // const rightLine = new Line(intersectPoint.x, intersectPoint.y, whoIsNotIn[j][0].x, whoIsNotIn[j][0].y);
          const leftAngle = midLine.angle(l1);
          const rightAngle = midLine.angle(l2);
          const leftTriangleArea = 0.5 * radius * midLine.length() * sin(leftAngle/2);
          const rightTriangleArea = 0.5 * radius * midLine.length() * sin(rightAngle/2);
          const sectorArea = 0.5 * radius * radius * alpha;
          const doublyCountedArea = sectorArea - rightTriangleArea - leftTriangleArea;
          totalArea -= doublyCountedArea;
          // other lengths:
          // 
          // console.log(alpha) 
      }
      line(l.x, l.y, l.ex, l.ey);
      const theta = 2 * (asin(l.length()/(2* radius)));
      const areaOfSegment = 0.5 * radius * radius * ( theta - sin(theta));
      totalArea += areaOfSegment;
  }
  if (totalArea != 0){
    console.log(totalArea);
    noLoop();
  }
}

function setup() {
  let canvas = createCanvas(windowWidth, windowHeight);
  canvas.parent(cDiv);
  points.push(createVector(-400, -400));
  // points.push(createVector(0, -500));
  points.push(createVector(0, 0));
  radii.push(0, 0, 0);
  cols.push(color(255,0,0, 100), color(0,255,0, 100), color(0,0,255, 100))
  polygonLines = [
    new Line(-500, -600, 500, -600),
    new Line(500, -600, 500, 600),
    new Line(500, 600, 450, 600), 
    new Line(450, 600, 450, 500),
    new Line(450, 500, -500, 500),
    new Line(-500, 500, -500, -600)
  ];
  for (let i=0; i<points.length; ++i){
    let temp = [];
    for (let j=0; j<points.length; ++j){
      temp.push(null);
    }
    boundaries.push(temp);
  }
}

function findIntersectionPoints(c1, c2, r1, r2){
  const a = c1.x, b=c1.y, c=c2.x, d=c2.y;
  const A = c - a, B = d-b;
  const C = r2*r2 - A*A - B*B;
  const D = -C/(2*A) + r1*r1/(2*A);
  const gamma = B/A;
  const alpha = gamma*gamma + 1;
  const beta = -2 * D * gamma;
  const delta = D*D - r1*r1;
  const disc = sqrt(beta * beta - 4 * alpha * delta);
  let y1, y2, x1, x2;
  // todo if B==0
  if (A == 0){
      y1 = -1/(2*B) * (r2*r2 - r1*r1 - B*B);
      y2 = y1;
      const t = r1*r1 - y1*y1;
      x1 = sqrt(t);
      x2 = -x1;
  }else{
  y1 = (-beta + disc)/(2*alpha);
  y2 = (-beta - disc)/(2*alpha);
  x1 = D - gamma * y1;
  x2 = D - gamma * y2;
  }
  // console.log(y1, y2, x1, x2);
  stroke(0,255,0);
  strokeWeight(2);
  // push();
  // translate(a, b);
  // now to find xs
  // const x1 = D - gamma * y1;
  // const x2 = D - gamma * y2;
  lines.push([x1 + a, x2 + a, y1+ b, y2+ b]);

}



function draw() {
  translate(width/2, height/2);
    background(0);
    stroke(255, 0, 0);
    fill(255)
    for (let i=0; i<points.length; ++i){
      const p = points[i];
      calculateAreaOfCircleInsidePolygon(p, radii[i]);
      fill(255, 255, 255, 100);
      ellipse(p.x, p.y, radii[i]*2);
      fill(0);
      ellipse(p.x, p.y, 10);
    }
    for (let i=0; i< points.length; ++i){
      for (let j=i+1; j<points.length; ++j){
        // console.log(p5.Vector.sub(points[i], points[j]).mag(), radii[i] + radii[j])
        if ( p5.Vector.sub(points[i], points[j]).mag() < radii[i] + radii[j] ){
          // colliding.
          findIntersectionPoints(points[i], points[j], radii[i], radii[j]);
          const lastLine = lines[lines.length-1];
          boundaries[i][j] = lastLine;
          boundaries[j][i] = lastLine;
        }
      }
    }
    for (let i=0; i<radii.length; ++i) radii[i]+= speeds[i];
    for (let l of lines){
      stroke(0,255,0,100);
      // line(l[0], l[2], l[1], l[3]);
    }
    
    for (let i =0; i<boundaries.length; ++i){
     for (let j =i+1; j<boundaries.length; ++j){ 
      
    }
    }
 
    for (let i =0; i<boundaries.length; ++i){
      const boundary = boundaries[i];
      for (let l of boundary){
        if (l == null)continue;
        stroke(cols[i]);
        line(l[0], l[2], l[1], l[3]);
      }
    }
    for (let l of polygonLines){
      stroke(255, 255, 255, 100);
      line(l.x, l.y, l.ex, l.ey);
    }
}
